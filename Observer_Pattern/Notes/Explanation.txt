Observer Design Pattern is a behavioral pattern that establishes a one-to-many dependency between objects.
When the subject changes its state, all its observers are automatically notified and updated. 
It focuses on enabling efficient communication and synchronization between objects in response to state changes.

Real Life Use Of Observer Design Pattern
Social Media Notifications
Users (observers) get updates when someone they follow (subject) posts new content or status.
Stock Market Apps
Investors receive real-time updates when stock prices (subjects) change.
Event Listeners in GUIs
UI components observe user actions like clicks or keyboard input and respond accordingly.
Weather Monitoring Systems
Multiple displays or devices update automatically when the central weather data changes.

When not to use the Observer Design Pattern?
Below is when not to use observer design pattern:
When the relationships between objects are simple and don’t require notifications.
When performance is a concern, as many observers can lead to overhead during updates.
When the subject and observers are tightly coupled, as it defeats the purpose of decoupling.
When number of observers is fixed and won’t change over time.
When the order of notifications is crucial, as observers may be notified in an unpredictable sequence.

Look at illustration2
Subject: Maintains a list of observers, provides methods to add/remove them, and notifies them of state changes.
Observer: Defines an interface with an update() method to ensure all observers receive updates consistently.
ConcreteSubject: A specific subject that holds actual data. On state change, it notifies registered observers (e.g., a weather station).
ConcreteObserver: Implements the observer interface and reacts to subject updates (e.g., a weather app showing weather updates).